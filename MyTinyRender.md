**MyTinyRender Notes**

已经学习完了**GAMES101**的光栅化部分，经b站评论区的推荐，复刻一下这个小而精美的渲染器，期待能在完成此项目的过程中掌握上课学的图形学，以及锻炼cpp能力。  

# Step0：tgaimage API

教程中给出了开始的**main**代码，直接开始研究直线了。但是发现对所用的**TGA**格式没有介绍，却还用了直接的一个库，并且进行了调用。  

既然本项目就使用**TGA**格式了，并且给的**tagimage**库内容并不多，所以我计划先把**TGA的基本格式**以及这个**库的api**学习了解，再进行后续的内容。  

[此Wiki链接是TGA的相关介绍](https://en.wikipedia.org/wiki/Truevision_TGA)，但是不怎么全，看的[这一篇详细的文章](https://blog.csdn.net/weixin_39587822/article/details/111693869)。  

库的实现没有看，但是每一个api都已看明白并注释完全，可以准备后面的应用。  

# Step1：Bresenham’s line drawing algorithm

研究了一下make和cmake，现在这个工程还小，可以等完成基本功能后按照现代的组织方式将代码组织起来。  

## first：homemade

手册里展示了多次尝试，从而使绘制的线逐渐满足几个要求：  
+ 陡峭时不能断开，要连续
+ 交换起点终点时，绘制的像素必须完全一致

我的第一次尝试就实现了比较好的效果，原因是考虑到了**步数应该是可变的**，而不应该定死为多少次；其次是我的绘制逻辑是按照**总偏移量x当前比例**，与画线方向无关；还有**比例依据**不应是单独的一个方向，而是整个的斜边，这样鲁棒性更强。  

但有一点与示例不同，我这里的走样更大。成因是实例的绘制逻辑是选定一个方向自增，有固定的步长1，每次画一块，所以线比较细；我的实现与x轴y轴无相关，只是根据综合得来的比例来决定步长，有时就会挤在一起。  

## second：DDA

要想效果更好，得到匀称的直线，就必须要用这种经典的DDA算法，十分简洁；  
并且后面的关键算法**Bresenham**还得以这个“标准答案”为引子。  

这里实现的**DDA算法**很妙：首先使各参数都满足算法基于的条件，然后在该条件上实现算法。  
这使算法不用考虑其他非理想情况，因为前面的处理自动使**非理想情况转换为理想情况**——当然，这也是基于几何问题的某种对称性。总之，相当于将输入的点抽象为一个理想接口，供算法调用。  

### 满足条件

+ 线要是**从左往右走**：若a点x坐标大于b点x坐标，则**交换两点坐标**，这一性质保证了起点终点交换时绘制的图像是一致的；  
+ x方向偏移量大于y方向偏移量：若x方向偏移量小于y方向偏移量，则交换x、y坐标，但在最后set时再反过来，这一性质相当于把“陡峭”的线转换为平缓的线，计算完毕后再换回去。  

### 算法执行

已有的条件：起点a、终点b，并且x轴投影大于y轴投影。  

那么从起点a出发，沿着x轴，每步走一格，同时根据直线公式推导y轴的值即可。  

由于x投影大于y投影，所以x走一步，y增长量不会大于1，这样就将y夹在了限定的两个格子里；反之，若沿着y，每走一步x的增长量就未知了，甚至可能断掉。  
就像0-90度的tan三角函数，0-45对应的值域是0-1，45-90对应的值域是1-无穷，自然0-45的好控制。  

## third：Bresenham

这里的算法起先并未写成代码，而只是进行了算法的思考。  
看那本《计算机图形学》其实也看到过这一经典算法，但是说实话没看懂推导；  
但今天这一思考，终于懂了。  

### 思路历程

首先，不要把问题复杂化，沿用DDA的经验，只考虑0-45度的“缓坡”。  

基于DDA的思路继续往下，由直线的性质，可以知道x每自增1，y的增量都是固定的k(斜率)，所以y坐标是一个等差数列。  

我们每次只能在y上的两个像素选择一个进行绘制，因此把其序列（或者左下角坐标）认为是真实坐标，而原直线经过的点是理想坐标（这里只考虑x为整数时；如果要考虑中间值，不妨把光栅分的更细，这样又是一个整数了），所以每次肯定是要选择离理想坐标更近的那个真实坐标所代表的像素。  

远近这个概念十分容易理解，尤其在图像上，试想从起点出来的第一个点，前面的假设使我们知道其y轴偏移量（也就是k！）一定是在0-1之间的，那么自然地，可以得到一个结论：k>0.5时选偏移的那颗像素，否则选连起来的那一颗(记得闫老师的网课说过，图形学这里的边界条件区分并不严格，等号靠哪一边都可以，因为看起来对，就不要动了......)。  

那么后面的点呢？这里就把y轴偏移量推广，其本质上是真实坐标与理想坐标之间的差异在第一个点的特殊情况，所以开始研究这个差异error，现在还是一个浮点。  

在起点时，error自然是0；走一步之后，根据k的值，真实坐标与理想坐标的error有两种情况：  
1. k<=0.5，那么真实坐标是相邻的那颗像素，error积累，变为0+k；  
2. k>0.5，真实坐标是偏移的那颗像素，error同样积累，只是基准改变，从真实像素来看，偏移量是k-1。  

从这就能看出点普遍性的东西了：error是一个逐渐积累的过程，并且可以是一个简单的循环：  
获取误差-->走一步，获取理想坐标-->决定真实坐标-->获取误差......  
极妙啊！  

上面这个error是浮点，众所周知，浮点慢，这还有优化空间吗？  
当然有！几何的特点发力：相似三角形。这里的比例都终归是有理数，放缩一定的倍数后就成为整数了，把这个倍数应用到刚才的整个计算流程，一切都简化为整数了。  

具体的计算、扩大化流程，可以在方格纸上按照一个比例来，然后实操，来发现规律。  
譬如我是模拟了从(0,0)到(4,3)的这一过程，然后扩大、分析、得到结果的。  

向Bresenham教授致敬。  

### 现实

传统印象里，int类运算一定快于float的运算，所以很自然的把DDA算法更新为Bresenham算法。但是实测却慢，为什么？  

问题不在于int类型，其的确是快于float的，真正的关键是`if(ierror > x_shift)`，由于ierror的大小不断浮动，cpu不好判断，预测错误多，导致CPU空转时间长、效率低。  

可以按照作者的方式来实地检验一下。  
引入std的chrono库，其可以得到高精度的时间；再引入随机库绘制即可。  

实测得到：  
+ DDA：17.343633
+ Bresenham：17.005029

能快一点，但十分的不明显，可见是用整数优化得来的时间被if的空转占用了。  

根据作者的优化方法，把if的分支判断优化改为直接的写法，最终时间为13.279811，效率的确提高了。  

这里一定还没有到达极致的优化，因为还可以做内联等，手册中并没有带着做，日后可以在这上面进行优化。  

另外，bresenham算法在当时的硬件基础上也有特别的意义。早期计算机没有计算浮点数的单元FPU，因此能且仅能用整形进行光栅绘制；直到后来FPU作为配件、最后集成到CPU中，硬件性能才逐渐提高；对应的浮点运算库也才逐渐提高。但其美丽的性质依然比浮点快，最高的山、最长的河。  

## homework

写完只感到舒畅，尽管过程还是很经典的痛苦。  
bug基本均匀的出现在各个步骤中，并且最后统一的出现在最后绘制的图像里，依此来倒推不对劲的地方。  

### obj文件读取

问题在于没有好好看文档，没有了解每一行都是干什么的。  

#### 没有对注释行进行处理

跑了半天没有出现结果，中止后在每一个进程中加上对应的提示，发现一直没有读取成功，于是想看看是在哪里死循环，于是打印行类型linetype，发现是井号#，原来是没有处理注释的逻辑，导致哪里出了问题，进入死循环。  

#### f行的实际含义

一个f行的结构大概如此：  
f 503/545/503 514/551/514 537/552/537  

没有细看，以为这代表了三个面，每一项是一个面的三顶点索引。但实际上是顶点索引/顶点纹理坐标索引/顶点法线索引，导致相当于解析了个错的，并且开销还是三倍。  

### bresenham算法的实现细节

发现有的线都莫名向外面飘去，想到可能是陡峭判断那里的drawLine出了问题，于是把问题简化为一开始的例子，画完线，的确是飘了，但并不是陡峭判断的问题，而是shift2赋值处，写的是`(by-ay)?1:-1`，实际上会恒为1,统一都向上飘，要改成`(((by-ay)>0)?1:-1)`。  

### 综合未解之谜

前面弄错的时候，发现一个模型初加载时很慢，但是后面哪怕再编译，分辨率改变，很快就绘制出来。可能是哪里有内存的残留；  

但是当f的读取正常后，绘制都是瞬间的，可能是这里提升了大量的性能。  






