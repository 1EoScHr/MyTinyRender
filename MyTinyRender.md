**MyTinyRender Notes**

已经学习完了**GAMES101**的光栅化部分，经b站评论区的推荐，复刻一下这个小而精美的渲染器，期待能在完成此项目的过程中掌握上课学的图形学，以及锻炼cpp能力。  

# Step0：tgaimage API

教程中给出了开始的**main**代码，直接开始研究直线了。但是发现对所用的**TGA**格式没有介绍，却还用了直接的一个库，并且进行了调用。  

既然本项目就使用**TGA**格式了，并且给的**tagimage**库内容并不多，所以我计划先把**TGA的基本格式**以及这个**库的api**学习了解，再进行后续的内容。  

[此Wiki链接是TGA的相关介绍](https://en.wikipedia.org/wiki/Truevision_TGA)，但是不怎么全，看的[这一篇详细的文章](https://blog.csdn.net/weixin_39587822/article/details/111693869)。  

库的实现没有看，但是每一个api都已看明白并注释完全，可以准备后面的应用。  

***

# Step1：Bresenham’s line drawing algorithm

研究了一下make和cmake，现在这个工程还小，可以等完成基本功能后按照现代的组织方式将代码组织起来。  

## first：homemade

手册里展示了多次尝试，从而使绘制的线逐渐满足几个要求：  
+ 陡峭时不能断开，要连续
+ 交换起点终点时，绘制的像素必须完全一致

我的第一次尝试就实现了比较好的效果，原因是考虑到了**步数应该是可变的**，而不应该定死为多少次；其次是我的绘制逻辑是按照**总偏移量x当前比例**，与画线方向无关；还有**比例依据**不应是单独的一个方向，而是整个的斜边，这样鲁棒性更强。  

但有一点与示例不同，我这里的走样更大。成因是实例的绘制逻辑是选定一个方向自增，有固定的步长1，每次画一块，所以线比较细；我的实现与x轴y轴无相关，只是根据综合得来的比例来决定步长，有时就会挤在一起。  

## second：DDA

要想效果更好，得到匀称的直线，就必须要用这种经典的DDA算法，十分简洁；  
并且后面的关键算法**Bresenham**还得以这个“标准答案”为引子。  

这里实现的**DDA算法**很妙：首先使各参数都满足算法基于的条件，然后在该条件上实现算法。  
这使算法不用考虑其他非理想情况，因为前面的处理自动使**非理想情况转换为理想情况**——当然，这也是基于几何问题的某种对称性。总之，相当于将输入的点抽象为一个理想接口，供算法调用。  

### 满足条件

+ 线要是**从左往右走**：若a点x坐标大于b点x坐标，则**交换两点坐标**，这一性质保证了起点终点交换时绘制的图像是一致的；  
+ x方向偏移量大于y方向偏移量：若x方向偏移量小于y方向偏移量，则交换x、y坐标，但在最后set时再反过来，这一性质相当于把“陡峭”的线转换为平缓的线，计算完毕后再换回去。  

### 算法执行

已有的条件：起点a、终点b，并且x轴投影大于y轴投影。  

那么从起点a出发，沿着x轴，每步走一格，同时根据直线公式推导y轴的值即可。  

由于x投影大于y投影，所以x走一步，y增长量不会大于1，这样就将y夹在了限定的两个格子里；反之，若沿着y，每走一步x的增长量就未知了，甚至可能断掉。  
就像0-90度的tan三角函数，0-45对应的值域是0-1，45-90对应的值域是1-无穷，自然0-45的好控制。  

## third：Bresenham

这里的算法起先并未写成代码，而只是进行了算法的思考。  
看那本《计算机图形学》其实也看到过这一经典算法，但是说实话没看懂推导；  
但今天这一思考，终于懂了。  

### 思路历程

首先，不要把问题复杂化，沿用DDA的经验，只考虑0-45度的“缓坡”。  

基于DDA的思路继续往下，由直线的性质，可以知道x每自增1，y的增量都是固定的k(斜率)，所以y坐标是一个等差数列。  

我们每次只能在y上的两个像素选择一个进行绘制，因此把其序列（或者左下角坐标）认为是真实坐标，而原直线经过的点是理想坐标（这里只考虑x为整数时；如果要考虑中间值，不妨把光栅分的更细，这样又是一个整数了），所以每次肯定是要选择离理想坐标更近的那个真实坐标所代表的像素。  

远近这个概念十分容易理解，尤其在图像上，试想从起点出来的第一个点，前面的假设使我们知道其y轴偏移量（也就是k！）一定是在0-1之间的，那么自然地，可以得到一个结论：k>0.5时选偏移的那颗像素，否则选连起来的那一颗(记得闫老师的网课说过，图形学这里的边界条件区分并不严格，等号靠哪一边都可以，因为看起来对，就不要动了......)。  

那么后面的点呢？这里就把y轴偏移量推广，其本质上是真实坐标与理想坐标之间的差异在第一个点的特殊情况，所以开始研究这个差异error，现在还是一个浮点。  

在起点时，error自然是0；走一步之后，根据k的值，真实坐标与理想坐标的error有两种情况：  
1. k<=0.5，那么真实坐标是相邻的那颗像素，error积累，变为0+k；  
2. k>0.5，真实坐标是偏移的那颗像素，error同样积累，只是基准改变，从真实像素来看，偏移量是k-1。  

从这就能看出点普遍性的东西了：error是一个逐渐积累的过程，并且可以是一个简单的循环：  
获取误差-->走一步，获取理想坐标-->决定真实坐标-->获取误差......  
极妙啊！  

上面这个error是浮点，众所周知，浮点慢，这还有优化空间吗？  
当然有！几何的特点发力：相似三角形。这里的比例都终归是有理数，放缩一定的倍数后就成为整数了，把这个倍数应用到刚才的整个计算流程，一切都简化为整数了。  

具体的计算、扩大化流程，可以在方格纸上按照一个比例来，然后实操，来发现规律。  
譬如我是模拟了从(0,0)到(4,3)的这一过程，然后扩大、分析、得到结果的。  

向Bresenham教授致敬。  

### 现实

传统印象里，int类运算一定快于float的运算，所以很自然的把DDA算法更新为Bresenham算法。但是实测却慢，为什么？  

问题不在于int类型，其的确是快于float的，真正的关键是`if(ierror > x_shift)`，由于ierror的大小不断浮动，cpu不好判断，预测错误多，导致CPU空转时间长、效率低。  

可以按照作者的方式来实地检验一下。  
引入std的chrono库，其可以得到高精度的时间；再引入随机库绘制即可。  

实测得到：  
+ DDA：17.343633
+ Bresenham：17.005029

能快一点，但十分的不明显，可见是用整数优化得来的时间被if的空转占用了。  

根据作者的优化方法，把if的分支判断优化改为直接的写法，最终时间为13.279811，效率的确提高了。  

这里一定还没有到达极致的优化，因为还可以做内联等，手册中并没有带着做，日后可以在这上面进行优化。  

另外，bresenham算法在当时的硬件基础上也有特别的意义。早期计算机没有计算浮点数的单元FPU，因此能且仅能用整形进行光栅绘制；直到后来FPU作为配件、最后集成到CPU中，硬件性能才逐渐提高；对应的浮点运算库也才逐渐提高。但其美丽的性质依然比浮点快，最高的山、最长的河。  

## homework

写完只感到舒畅，尽管过程还是很经典的痛苦。  
bug基本均匀的出现在各个步骤中，并且最后统一的出现在最后绘制的图像里，依此来倒推不对劲的地方。  

### obj文件读取

问题在于没有好好看[obj文件文档](https://en.wikipedia.org/wiki/Wavefront_.obj_file#)，没有了解每一行都是干什么的。  

#### 没有对注释行进行处理

跑了半天没有出现结果，中止后在每一个进程中加上对应的提示，发现一直没有读取成功，于是想看看是在哪里死循环，于是打印行类型linetype，发现是井号#，原来是没有处理注释的逻辑，导致哪里出了问题，进入死循环。  

#### f行的实际含义

一个f行的结构大概如此：  
f 503/545/503 514/551/514 537/552/537  

没有细看，以为这代表了三个面，每一项是一个面的三顶点索引。但实际上是顶点索引/顶点纹理坐标索引/顶点法线索引，导致相当于解析了个错的，并且开销还是三倍。  

### bresenham算法的实现细节

发现有的线都莫名向外面飘去，想到可能是陡峭判断那里的drawLine出了问题，于是把问题简化为一开始的例子，画完线，的确是飘了，但并不是陡峭判断的问题，而是shift2赋值处，写的是`(by-ay)?1:-1`，实际上会恒为1,统一都向上飘，要改成`(((by-ay)>0)?1:-1)`。  

### 综合未解之谜

前面弄错的时候，发现一个模型初加载时很慢，但是后面哪怕再编译，分辨率改变，很快就绘制出来。可能是哪里有内存的残留；  

但是当f的读取正常后，绘制都是瞬间的，可能是这里提升了大量的性能。  

# Step1：Triangle rasterization

一个**优秀的三角形填充算法**应该具有的特性;  
1. 应该**简洁**而**高效**
2. 应该具有**对称性**，无论输入顺序如何变化
3. 两个三角形共享顶点时，不应出现缝隙等

## First：Homemade

这个项目有趣就有趣在每次都要先自己搓一套东西出来，然后对比，再讲更现代化的。  
尽管自己搓这么一套很难，好不容易实现，一对比，又被暴打，很是难过，不过也算是造轮子前的自我检验，涨经验。  

这一套是稍微看了一下**扫描线填充法**后自己瞎想出的**思路**：  
+ 首先对三个点的坐标进行**排序**，确保ay > by > cy这样
+ 然后正常计算三条边，只不过是还另外的把每一条线的**每一个点的x轴信息**记录下来
+ 分别从ay与cy遍历到by，绘制直线来填充，范围根据上一点的x轴信息解算出来

思路是勉强能算是简洁的，但是实现起来的**细节**十分**丑陋**：  
+ 重载了drawLine函数，还是基于Bresenham直线算法的那个，只是不直接绘制，而是通过一个`vector<int>`变量记录线上每个点的x轴信息。（其实一开始的想象很美好，计划用bool向量存放，因为每条直线绘制是都是**不陡峭**的，随着x变化记录下y每次是否偏移就描述了整条直线。但现实是，最终填充时用x方向的直线填充，在陡峭直线的情况下还能根据y方向上增加1，x方向只有0/1的偏移来根据初始值确定x，但是遇到非陡峭的情况时，一个y对应了许多x，那么是按照最左还是最右算？“提前把边缘画好，这样就无所谓”也是一种方法，但我就希望drawLine的时候不绘制，只获取必要信息。没办法，只能放弃我想象的bool描述，直接用int记录具体坐标了）（实际上“按照最左还是最右算”这个认知也是错误的，绘制直线时非陡峭在一个y上有一长条，实际上唯一有价值的是刚shift的那个点，剩下的长条只不过是占位符，等待着下一个shift的点。这一点有关的认知在第三个丑陋之处还有提出）
+ 由于获取直线信息时本质是执行了一次Bresenham直线算法，所以会发生起点终点的交换，不加以处理的话绘制出来就是倒着的，所以加了一个标志位`is_swap`来作为返回值，如果交换了，就把返回的vector元素全部都倒过来，用`std::reverse(vec.begin(), vec.end())`的写法，这是真学到的东西，没得黑。（其实这里就已经蠢的略显端倪了，既然vec在函数体内填充数值，出来后颠倒vec的操作是根据函数体内算出来的标志位，那么为什么不直接在函数体内就完成呢？唉唉。）
+ 发现绘制出来的三角形，边为陡峭直线就没问题，但非陡峭直线就无法填充，只是一个等边直角三角形。细细debug一番，发现原因在于drawLine中存放x轴信息时多存了那些没用的用于占位的值。在陡峭情况下，一个x能对应多个y，但一个y只能对应一个x，因此填充时能够对上；但是非陡峭时，情况反过来，一个y能对应多个x，可是填充时y不会等待，最后就变成了等边直角。解决方案就是在非陡峭情况下，增加一个判断，如果下一个像素不能够偏移，那么就应该删掉，一直到下一个要偏移（这里就与第一条的那个顿悟对应上了）。实现逻辑是`if(ierror > x_shift){vec.pop_back()}`，这里就来很熟悉的问题了：if对性能的影响很大。前面那修正的方法能用，但是pop_back()可就没法这样了，难道必须看着做的优化一夜回到解放前？询问GPT，给了个好法子：`if(!is_steep) { x_step.resize(x_step.size() - !(ierror-x_shift); }`，真是学到这个妙法了。  

以上三点就是对自己这个homemade的方法的剖析，花了好长时间，能用，但是丑陋，最后还是要变成注释，为正经的方法让路，唉；但是至少学到了两个用法，还行！  

## Second：正经的Scanline rendering扫描线渲染

给的这个示例真的极其简洁，作者那些话果然是自谦。  

标准的方法思路其实我很接近，只是又走了错路：  
+ 首先依然是对坐标进行排序
+ 然后按照上下两个平底三角形分别渲染

这里的牛逼之处在于跳出了上一课画直线的窠臼，敏锐的意识到直接用斜率推导坐标的可行之处：DDA中还得考虑陡峭与非陡峭，因为画出来的线不能是虚线；但是填充时是虚线也无所谓（这也是上面提到的），只有虚线的信息才是关键信息，其余只是为了填空。  

基本原理：由`y = y1 + (y2-y1)/(x2-x1)*(x-x1)`，结合x与y的对称性，得到`x = x1 + (x2-x1)/(y2-y1)*(y-y1)`，这便是基本的原理。  

精妙之处：  
+ 对于式子中的“除以y2-y1”，为防止除零错误，需要保证三条直线的这个值不能为零（也就是ay!=by、ay!=cy、by!=cy），三个条件看似很难办，实际上一一分析：首先**ay一定不等于cy**，因为这样会使三角形退化为一个线段；然后是ay!=by，实际上满足是是一个**上平底三角形**，上面本来就不用填充；同理，当cy!=by时，实际上是一个**下平底三角形**，下面本来就不用填充三角形。因此，需要满足的条件都能对应上。
+ 使用了整数除法，而不是浮点除法，并且没有丢失精度。乍一看，没有转换任何一个类型为浮点，整数除整数，精度肯定丢失。但实际上，通过把除法分离到最后执行，完美规避了这一风险：`x = cx + (ax-cx)*(y-cy)/(ay-cy)`，乘法部分与浮点计算等价，除法则很神奇的省略了最后截取整数部分的开销，保留精度+优化性能，完美。  

## Third：现代化的三角形填充法

对于多核CPU以及GPU，我们可以跳出扫描线渲染法，考虑更加**大力出奇迹**的现代方法。  

思路就是：  
+ **遍历**屏幕上的所有像素
+ 如果该像素位于三角形内，就画出来

极其的符合**直觉**、极其的**简洁**，配合上多核CPU或者GPU的**并行化**，能够极大的加速。  

**妙处**：  
+ 用**boundbox**来缩小遍历范围，从三角形的外接Bbox开始遍历，而不是整张图
+ 用**重心坐标**相关判据来判断像素是否在三角形内：点P对于三角形ABC的重心坐标是`(Area(PBC)/Area(ABC), Area(APC)/Area(ABC), Area(ABP)/Area(ABC))`，若**任意一分量**小于0，可以判断出**点P在ABC外**；由于Area的正负实际上表示的是排列方向（见下），所以分子都可以写成P在第一个的格式，只要满足A-B-C-A的循环关系
+ 用**有向面积替代重心坐标计算**，其中Area(XYZ)表示三角形XYZ的**有向面积**，即*u*✖*v*(*xy*✖*xz*)，在二维中等价于`u_x*v_y-u_y*v_x`标量；此外，有向面积还代表了三点的**顺/逆时针**顺序。这样为了筛出重心坐标为负的分量，可以综合原三角形ABC的有向面积正负与点P与每条边的正负；此外**再进一步**，为什么不写成判断三个是否相等的格式？不可能存在大三角形按顺时针，三个小三角形却是逆时针，反过来也一样（这样综合起来就与GAMES101中给的方法对应了：GAMES101给的方法是APxAB、BPxBC、CPxCA同号则能判断出点在三角形内，而这里同样用的叉乘，只不过是整体来看，**都描述的是同一个物理事实**）
+ 实现了一个简易的**透视算法**，说是算法，其实代码中也就一行，关键是在于其思想。先把问题**简化**为一个二维图像投影到一维屏幕上，假定这个二维图像是一个任意多边形，每个线段收尾相接(如AB、BC……)，可以发现在屏幕上的投影同向的都在一面，所以一个物体的正反面，似乎能够在屏幕上的投影的某种性质来进行判断。拓展到三维空间投影到二维屏幕，可以使用**有向面积**的正负来简易的判断（基于.obj文件三角形在法线方向看都是顺/逆时针，更具体的例子可以在注释中看到）

